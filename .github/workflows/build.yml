name: Build and Test

on: 
  workflow_dispatch:
  pull_request:    
  push:
    branches:
       - main
  release:
    types: [published]

concurrency:
  # from iree CI:
  # A PR number if a pull request and otherwise the commit hash. This cancels
  # queued and in-progress runs for the same PR (presubmit) or commit
  # (postsubmit). The workflow name is prepended to avoid conflicts between
  # different workflows.
  group: ${{ github.workflow }}-${{ github.event.number || github.sha }}
  cancel-in-progress: true  

jobs:

  build:

    name: Build compiler and runtime

    if: ${{ vars.CODEBUILD_PROJECT_CODEBASE != ''}}

    runs-on:
      - codebuild-${{ vars.CODEBUILD_PROJECT_CODEBASE }}-${{ github.run_id }}-${{ github.run_attempt }}

    env:
      SCCACHE_BUCKET: ${{ vars.SCCACHE_BUCKET }}
      SCCACHE_REGION: ${{ vars.AWS_REGION }}
      SCCACHE_S3_KEY_PREFIX: clang-build

    permissions:
      contents: read
      id-token: write

    steps:

      - name: Assume AWS role to access cache
        uses: aws-actions/configure-aws-credentials@v5.1.0
        id: assume_role
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # only the main branch role has permissions to write to the cache
          role-to-assume: ${{ github.ref == 'refs/heads/main' && vars.MAIN_BRANCH_ROLE_ARN  || vars.PULL_REQUEST_ROLE_ARN }}

      - name: Show active AWS identity
        run: |
          aws sts get-caller-identity

      - name: Make cached checkout visible to workflow
        run: |
          # actions/checkout and uses keyword can only access files within the current workflow workspace
          ln -s /workspace/code .

      - name: Update checkout
        uses: actions/checkout@v4
        with:
          path: code
          lfs: true

      - name: Update required submodules
        working-directory: /workspace/code
        run: |
          bash scripts/checkout_submodules.sh        

      - name: Configure python venv for host build and test
        working-directory: /workspace/code
        run: |
          ./scripts/configure_python.sh /workspace/venv /workspace/build

      - name: Configure build for host
        working-directory: /workspace/code
        run: |
          ./scripts/configure_build.sh /workspace/build

      - name: Build for host
        working-directory: /workspace/build
        env:
          SCCACHE_SERVER_UDS: ${{github.workspace}}/sccache.sock
        run: |
          sccache --start-server
          cmake --build .
          sccache --show-stats

      - name: Configure build for soc
        working-directory: /workspace/code
        run: |
          ./scripts/configure_soc_build.sh /workspace/build-soc /workspace/build

      - name: Build for soc
        working-directory: /workspace/build-soc
        run: |
          cmake --build . --target iree-run-module

      - name: Set tag variable
        id: vars
        run: |
          if [ "${{ github.event_name }}" = "release" ] && [ "${{ github.event.action }}" = "published" ]; then
            echo "TAG=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          else
            echo "TAG=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi
        
      - name: Gather release files
        env:
          HF_TOKEN: ${{ secrets.HF_TOKEN }}
        run: |
          /workspace/code/scripts/assemble_release_docker.sh /workspace/build /workspace/build-soc release
          echo "${{ steps.vars.outputs.TAG }}" > release/VERSION
          tar -zcf release.tar.gz release

      - name: Upload release files
        uses: actions/upload-artifact@v4
        with:
          name: release
          path: release.tar.gz
          retention-days: 30

  test_cmodel:
    name: Test with C model

    needs: [ build, user_doc_build ]

    permissions:
      contents: read
      id-token: write  # this is required to assume the AWS role

    strategy:
      fail-fast: false
      matrix:
        chip_group: [ default.group , next.group ]

    runs-on:
          - codebuild-${{ vars.CODEBUILD_PROJECT_CODEBASE }}-${{ github.run_id }}-${{ github.run_attempt }}
            image:custom-linux-${{ vars.ECR_REGISTRY }}/${{ vars.ECR_REPOSITORY }}:latest-tests

    outputs:
      s3_cache_path: ${{ steps.run_cmodel_tests.outputs.s3_cache_path }}

    steps:

      # this is required to be able to upload the artifacts to S3
      - name: Assume AWS role
        uses: aws-actions/configure-aws-credentials@v5.1.0
        id: assume_role
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ github.ref == 'refs/heads/main' && vars.MAIN_BRANCH_ROLE_ARN  || vars.PULL_REQUEST_ROLE_ARN }}

      - name: Checkout repository
        if: ${{ vars.DISABLE_TESTS != 'true' }}
        uses: actions/checkout@v4
        with:
          lfs: false
          submodules: false
    
      - name: Run C model tests
        id: run_cmodel_tests
        if: ${{ vars.DISABLE_TESTS != 'true' }}
        uses: ./.github/actions/tests
        with:
          app_id: ${{ vars.CI_APP_ID }}
          app_private_key: ${{ secrets.CI_APP_PRIVATE_KEY }}
          extra_repo: ${{ vars.EXTRAS_REPO }}
          hf_token: ${{ secrets.HF_TOKEN }}
          test_data_cache_artifact: ${{ (github.event_name == 'push' && github.ref == 'refs/heads/main' && format('test-cache-{0}', matrix.chip_group)) || '' }} # upload to github only on main branch 
          pytest_args: -m ci -n auto -v --performance-report=${{ github.workspace }}/host_test_performance_${{ matrix.chip_group }}.csv --torq-chips ${{ matrix.chip_group }}
          s3_bucket: ${{ vars.ARTIFACT_BUCKET }}
          
      - name: Upload host test performance
        if: ${{ vars.DISABLE_TESTS != 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: cmodel_test_performance_${{ matrix.chip_group }}
          path: ${{ github.workspace }}/host_test_performance_${{ matrix.chip_group }}.csv
          retention-days: 60

  test_aws_fpga:    
    name: Test with AWS FPGA on ${{ matrix.chip_group }}

    runs-on: torq-fpga-${{ github.run_id }}-${{ github.run_attempt }}

    if: ${{ (github.event_name == 'push' && github.ref == 'refs/heads/main') || contains(github.event.pull_request.labels.*.name || '', 'test-aws') }}

    needs: [ test_cmodel ]

    permissions:
      contents: read
      id-token: write  # this is required to assume the AWS role

    timeout-minutes: 50

    strategy:
      fail-fast: false
      matrix:
        # FIXME next chip fails
        #chip_group: [ default.group , next.group ]
        chip_group: [ default.group]

    steps:
      
      # this is required to be able to download artifacts from S3
      - name: Assume AWS role
        uses: aws-actions/configure-aws-credentials@v5.1.0
        id: assume_role
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ github.ref == 'refs/heads/main' && vars.MAIN_BRANCH_ROLE_ARN  || vars.PULL_REQUEST_ROLE_ARN }}

      - name: Clear FPGA slot
        if: ${{ vars.DISABLE_TESTS != 'true' }}
        run: |
          # the instance on which this is running may have already served another shell
          # so we need to clear the slot before running our tests to ensure a clean state
          fpga-clear-local-image -S 0
    
      - name: Checkout repository
        if: ${{ vars.DISABLE_TESTS != 'true' }}
        uses: actions/checkout@v4
        with:
          lfs: false
          submodules: false
    
      - name: Run AWS FPGA model tests
        if: ${{ vars.DISABLE_TESTS != 'true' }}
        uses: ./.github/actions/tests
        with:
          app_id: ${{ vars.CI_APP_ID }}
          app_private_key: ${{ secrets.CI_APP_PRIVATE_KEY }}
          extra_repo: ${{ vars.EXTRAS_REPO }}
          hf_token: ${{ secrets.HF_TOKEN }}
          precomputed_cache: ${{ needs.test_cmodel.outputs.s3_cache_path }}  # download from s3 the test cache generated by the cmodel tests, this gets the cache from the latest completed job in the cmodel matrix, it is ok for the moment
          pytest_args: -m fpga_ci -n auto --performance-report=${{ github.workspace }}/aws_fpga_test_performance_${{ matrix.chip_group }}.csv --torq-runtime-hw-type aws_fpga --torq-runtime-timeout=20 --torq-chips ${{ matrix.chip_group }}

      - name: Upload AWS FPGA test performance
        if: ${{ vars.DISABLE_TESTS != 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: aws_fpga_test_performance_${{ matrix.chip_group }}
          path: ${{ github.workspace }}/aws_fpga_test_performance_${{ matrix.chip_group }}.csv
          retention-days: 60

  # build the user part of the docs only
  user_doc_build:
      name : Build user guide
      runs-on: ubuntu-latest
      steps:
          - name: Checkout repository              
            uses: actions/checkout@v4
            with:
              lfs: true
              submodules: false

          - name: Build documentation              
            uses: syna-astra-dev/action-doc-publish/actions/doc-build@v3
            with:
              doc_dir: doc/user-manual

          - name: Upload documentation artifact              
            uses: actions/upload-artifact@v4
            with:
              name: user-manual
              path: _build/html     
              retention-days: 7

  docker_release:
    name: Release Docker image
    if: ${{ (github.event_name == 'push' && github.ref == 'refs/heads/main') || (github.event_name == 'release' && github.event.action == 'published') }}
    needs: test_aws_fpga
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write

    steps:
      - name: Download the compiler and runtime
        uses: actions/download-artifact@v4
        with:
          name: release
          path: release

      - name: Extract the compiler and runtime
        working-directory: release
        run: |
          tar -zxf release.tar.gz --strip-components=1

      - name: Docker meta (generate tags & labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}/compiler
          flavor: |
            latest=false
          tags: |
            type=ref,event=branch,enable=${{ github.ref == 'refs/heads/main' }}

            type=raw,value=${{ github.event.release.tag_name }},enable=${{ github.event_name == 'release' && github.event.action == 'published' }}
            type=raw,value=latest,enable=${{ github.event_name == 'release' && github.event.action == 'published' }}

      - name: Log in to Docker Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.github_token }}
      
      - name: Build and push release docker
        uses: docker/build-push-action@v6
        with:
          context: release
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          
  publish_release:
    name: Publish Release
    needs: [build, user_doc_build]
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'pull_request' }}
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4

      - name: Download release artifact
        uses: actions/download-artifact@v4
        with:
          name: release
          path: dist

      - name: Download user documentation
        uses: actions/download-artifact@v4
        with:
          name: user-manual
          path: dist/doc

      - name: Compress the user manual as a zip
        run: |
          cd dist
          zip -r doc.zip doc
          rm -rf doc

      - name: Ensure snapshot release exists
        if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
        env:
          GITHUB_TOKEN: ${{ secrets.github_token }}
        run: |
          if gh release view snapshot >/dev/null 2>&1; then
            echo "snapshot release exists"
          else
            gh release create snapshot \
              -t "Development Snapshot" \
              -n "Latest build from main. Unstable. Replaced on each commit." \
              --prerelease
          fi

      - name: Upload to GitHub release
        env:
          GITHUB_TOKEN: ${{ secrets.github_token }}
          EVENT_NAME: ${{ github.event_name }}
          EVENT_ACTION: ${{ github.event.action }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
        run: |
          if [[ "$EVENT_NAME" == "release" && "$EVENT_ACTION" == "published" ]]; then
            gh release upload "$RELEASE_TAG" dist/* --clobber
          else
            gh release upload snapshot dist/* --clobber
          fi
