#include "torq/Codegen/OutlineUtils.h"
#include "torq/Dialect/TorqHL/TorqHLOps.h"
#include "torq/Utils/MemoryUtils.h"

#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/MemRef/IR/MemRef.h"
#include "mlir/Dialect/Tensor/IR/Tensor.h"
#include "mlir/IR/IRMapping.h"
#include "mlir/Interfaces/FunctionInterfaces.h"

#include "llvm/Support/Debug.h"
#include "llvm/Support/FormatVariadic.h"

#include "iree/compiler/Codegen/Dialect/Codegen/IR/IREECodegenAttrs.h"
#include "iree/compiler/Dialect/Flow/IR/FlowDialect.h"
#include "iree/compiler/Dialect/Flow/IR/FlowOps.h"
#include "iree/compiler/Dialect/HAL/IR/HALDialect.h"
#include "iree/compiler/Dialect/HAL/IR/HALOps.h"

#define DEBUG_TYPE "torq-outline-utils"

using namespace mlir::iree_compiler;

namespace mlir::syna::torq {

static DenseSet<Operation *> getAllOpsIncludingNested(const SmallVector<Operation *> &targets) {
    DenseSet<Operation *> opsSet(targets.begin(), targets.end());

    for (auto op : targets) {
        op->walk([&](Operation *op) { opsSet.insert(op); });
    }

    return opsSet;
}

static SmallVector<Value> getOutputs(
    const SmallVector<Operation *> &targets, const DenseSet<Operation *> &targetsWithNested
) {
    SmallVector<Value> outputs;

    for (auto op : targets) {
        for (auto result : op->getResults()) {
            for (auto user : result.getUsers()) {
                if (!targetsWithNested.contains(user)) {
                    outputs.push_back(result);
                    break;
                }
            }
        }
    }

    LLVM_DEBUG({
        llvm::dbgs() << "---- outputs of the outlined function:\n";

        for (auto output : outputs) {
            output.dump();
        }
    });

    return outputs;
}

static SmallVector<Value>
getInputs(const SmallVector<Operation *> &targets, const DenseSet<Operation *> &targetsWithNested) {

    SmallVector<Value> inputs;

    for (auto op : targets) {
        op->walk([&](Operation *op) {
            for (auto operand : op->getOperands()) {

                // skip values that are generated by operations we are outlining
                if (targetsWithNested.contains(operand.getDefiningOp())) {
                    continue;
                }

                auto argOperand = dyn_cast<BlockArgument>(operand);

                // skip values that are block arguments of blocks inside operands we are outlining
                if (argOperand &&
                    targetsWithNested.contains(argOperand.getOwner()->getParentOp())) {
                    continue;
                }

                inputs.push_back(operand);
            }
        });
    }

    LLVM_DEBUG({
        llvm::dbgs() << "----  inputs of the outlined function:\n";

        for (auto input : inputs) {
            input.dump();
        }
    });

    return inputs;
}

static void copyToProgramBody(
    OpBuilder &builder, torq_hl::ProgramOp programOp, const DenseMap<Value, Value> &outputToInputs,
    const SmallVector<Value> &inputs, const SmallVector<Value> &outputs,
    const SmallVector<Operation *> &opsToCopy, bool destinationStyle
) {

    DenseMap<Value, Value> inputsToOutputs;
    for (auto [output, input] : outputToInputs) {
        inputsToOutputs.try_emplace(input, output);
    }

    OpBuilder::InsertionGuard guard(builder);

    IRMapping map;

    auto &block = programOp.getBody().front();

    builder.setInsertionPointToStart(&block);

    if (destinationStyle) {
        // add all the init arguments to the program body
        for (auto output : outputs) {

            auto initArg = block.addArgument(output.getType(), output.getLoc());

            // map any reference to the input corresponding to this output to the init argument
            auto input = outputToInputs.find(output);
            if (input != outputToInputs.end()) {
                map.map(input->second, initArg);
            }
        }
    }

    // add all the input arguments to the program body that cannot be
    // remapped to some inits
    for (auto input : inputs) {

        if (destinationStyle) {
            // this input will be substitute with an init vector
            if (inputsToOutputs.contains(input)) {
                continue;
            }
        }

        map.map(input, block.addArgument(input.getType(), input.getLoc()));
    }

    // clone all operations
    for (auto op : opsToCopy) {
        builder.clone(*op, map);
    }

    // add a return operation

    SmallVector<Value> returnValues;
    for (auto output : outputs) {
        returnValues.push_back(map.lookup(output));
    }

    builder.create<torq_hl::ReturnOp>(programOp.getLoc(), returnValues);
}

static int64_t getProgramSize(torq_hl::ProgramOp programOp) {

    // FIXME: we compute this based on the real content of the program
    if (programOp.getProgram().getType().getExecutor() == torq_hl::Executor::Slice) {
        return 0xA00;
    }
    else if (programOp.getProgram().getType().getExecutor() == torq_hl::Executor::NSS) {
        return 0x280;
    }
    else {
        assert(false && "Unsupported executor for program size calculation");
    }
}

static DenseMap<Value, Value> getOutputToInput(
    OpBuilder &builder, const SmallVector<Operation *> &targets, const SmallVector<Value> &inputs,
    const SmallVector<Value> &outputs
) {

    DenseMap<Value, Value> outputToInput;
    DenseSet<Value> inputSet(inputs.begin(), inputs.end());

    // for each output find a value that can be used as init
    for (auto output : outputs) {

        auto outputResult = cast<OpResult>(output);
        auto dsOp = output.getDefiningOp<DestinationStyleOpInterface>();

        if (!dsOp) {
            continue;
        }

        // find the init value for this output
        auto initValue = dsOp.getDpsInitOperand(outputResult.getResultNumber())->get();

        // if the init value is an input to the program we can use it as init
        if (inputSet.contains(initValue)) {
            outputToInput.try_emplace(output, initValue);
        }
    }

    return outputToInput;
}

FailureOr<OutliningResults> outlineProgram(
    OpBuilder &builder, std::string name, torq_hl::Executor executor,
    const SmallVector<Operation *> &targets, bool destinationStyle
) {
    auto loc = builder.getUnknownLoc();

    if (!targets.empty()) {
        loc = targets.front()->getLoc();
    }

    LLVM_DEBUG({
        llvm::dbgs() << "-- outlining operations:\n";
        for (auto op : targets) {
            op->dump();
        }
    });

    // create a set to help finding which ops we are outlining
    auto targetsWithNested = getAllOpsIncludingNested(targets);

    // find all the outputs of the outlined function
    auto outputs = getOutputs(targets, targetsWithNested);

    // find all inputs of the outlined function
    auto inputs = getInputs(targets, targetsWithNested);

    // try to find all inputs that can be used as init of the outputs
    DenseMap<Value, Value> outputToInputs;

    if (destinationStyle) {
        outputToInputs = getOutputToInput(builder, targets, inputs, outputs);
    }

    // create a new program that will contain the outlined operations
    auto programType = torq_hl::ProgramType::get(builder.getContext(), executor);
    auto programOp =
        builder.create<torq_hl::ProgramOp>(loc, programType, builder.getStringAttr(name));
    programOp.getBody().emplaceBlock();

    // copy the operations into the function body
    copyToProgramBody(
        builder, programOp, outputToInputs, inputs, outputs, targets, destinationStyle
    );

    return OutliningResults{programOp, inputs, outputs, outputToInputs};
}

} // namespace mlir::syna::torq