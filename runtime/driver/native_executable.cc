// Copyright 2024 Synaptics
// Copyright 2019 The IREE Authors
//
// Licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#include "native_executable.h"

#include "TorqHw.h"
#include "TorqUtils.h"
#include "TorqEventLog.h"
#include "iree/base/api.h"
#include "iree/tooling/numpy_io.h"
#include "iree/io/stdio_stream.h"

#include "iree/base/internal/flatcc/parsing.h"

#include "torq_executable_def_reader.h"
#include "torq_executable_def_verifier.h"

#include "iree/hal/pipeline_layout.h"
#include "iree/base/internal/flags.h"

#include <unistd.h>
#include <dlfcn.h>

#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <iostream>
#include <filesystem>
#include <limits>
#include <functional>
#include <map>

#undef ns
#define ns(x) FLATBUFFERS_WRAP_NAMESPACE(iree_hal_torq, x) 

IREE_FLAG(string, torq_desc_data_dir, "", "Use existing Torq API descriptor dump (generated by the compiler) as template for the Torq API data dump");
IREE_FLAG(string, torq_profile, "", "Create profiling log in the specified file");
IREE_FLAG(string, torq_profile_host, "", "Create host profiling log in the specified file");
IREE_FLAG(string, torq_dump_mem_data_dir, "", "Write Torq API data dump files to the specified directory");
IREE_FLAG(string, torq_dump_io_data_dir, "", "Dump input output buffers in binary form to the specified directory");
IREE_FLAG(bool, torq_debug, false, "Enable debug logs")
IREE_FLAG(bool, torq_verbose, false, "Enable verbose logs (more than debug logs)")
IREE_FLAG(bool, torq_step_by_step, false, "Enable step_by_step debug mode")
IREE_FLAG(string, torq_dump_buffers_dir, "", "Enable dumping intermediate buffers during execution to the specified directory")
IREE_FLAG(string, torq_hw_type, "sim", "Hardware type [sim, aws_fpga, soc_fpga, astra_machina]")
IREE_FLAG(bool, torq_clear_memory, false, "Force clearing XRAM and LRAM before starting execution")

namespace iree {
  namespace hal {
    namespace torq {}
  }
}

int TorqLogger::request_log_level = TORQ_LOG_NONE;

using namespace synaptics;
using namespace iree::hal::torq;
using namespace std;

namespace {

static bool binary_file_write(const std::string& file_name, const void* data, size_t size)
{
    std::ofstream wf;
    wf.open(file_name, std::ios::out | std::ios::binary);
    if (!wf.good()) {
        printf("Failed to open file: %s\n", file_name.c_str());
        return false;
    }

    if (data) {
        wf.write(static_cast<const char*>(data), size);
    }
    wf.close();
    return wf.good();
}

static std::string get_io_dump_data_dir(std::string executable_name) {
    if (!FLAG_torq_dump_io_data_dir[0]) {
        return "";
    } else {
      return std::string(FLAG_torq_dump_io_data_dir) + "/" + executable_name + "/";
    }
}

static std::string get_mem_dump_data_root_dir(std::string executable_name) {
    if (!FLAG_torq_dump_mem_data_dir[0]) {
        return "";
    } else {
      return std::string(FLAG_torq_dump_mem_data_dir) + "/" + executable_name;
    }
}

static std::string get_mem_dump_data_dir(std::string executable_name, int job_id) {
    if (!FLAG_torq_dump_mem_data_dir[0]) {
        return "";
    } else {
      return get_mem_dump_data_root_dir(executable_name) + "/job" + std::to_string(job_id) + "/";
    }
}

static std::string get_buffer_dump_dir(std::string executable_name, int job_id) {
    if (!FLAG_torq_dump_buffers_dir[0]) {
        return "";
    } else {
      return std::string(FLAG_torq_dump_buffers_dir) + "/" + executable_name + "/action" + std::to_string(job_id) + "/";
    }
}

static std::string get_mem_list_name(std::string executable_name, bool from_host, int job_id) {
    return get_mem_dump_data_dir(executable_name, job_id) + "tv." + (from_host ? "init" : "exit") + ".mem.lst";
}

static bool hex_file_write(string executable_name, string file_name, string type, int address, const void* data, size_t size, int job_id) {

    auto file_path = get_mem_dump_data_dir(executable_name, job_id) + file_name;

    LOGD << "Writing dump torq data to " << file_path;

    // dump the data as hex
    std::ofstream wf(file_path);
    if (!wf.good()) {
      LOGD << "Failed to open dump torq data file " << file_path;
        return false;
    }
    if (data) {
        for (size_t i = 0; i < size; i++) {
            wf << std::hex << std::setw(2) << std::setfill('0') << (int)((unsigned char*)data)[i] << '\n';
        }
    }
    wf.close();
    if (!wf.good()) {
        LOGD << "Failed to close dump torq data file " << file_path;
        return false;
    }
    // append the file name to the list of files in the corresponding mem.lst file
    FILE *fp = fopen(get_mem_list_name(executable_name, type != "xsave", job_id).c_str(), "a");
    fprintf(fp, "%s  0x%08x %10zu %3d  hex  %s\n", type.c_str(), address, size, 1, file_name.c_str());
    fclose(fp);
    return true;

}


extern const iree_hal_executable_vtable_t
    iree_hal_torq_native_executable_vtable;
}  // namespace

iree_hal_torq_native_executable_t*
iree_hal_torq_native_executable_cast(iree_hal_executable_t* base_value) {
  IREE_HAL_ASSERT_TYPE(base_value, &iree_hal_torq_native_executable_vtable);
  return (iree_hal_torq_native_executable_t*)base_value;
}

iree_status_t iree_hal_torq_native_executable_create(
    iree_hal_device_t* device,
    iree_allocator_t allocator,
    const iree_hal_executable_params_t* executable_params,
    iree_hal_executable_t** out_executable) {
  IREE_ASSERT_ARGUMENT(executable_params);
  IREE_ASSERT_ARGUMENT(out_executable);
  *out_executable = NULL;
  iree_allocator_t host_allocator = allocator;
  IREE_TRACE_ZONE_BEGIN(z0);

  iree_hal_torq_native_executable_t* executable = NULL;
  iree_status_t status = iree_allocator_malloc(
      host_allocator,
      sizeof(*executable) +
      executable_params->pipeline_layout_count * sizeof(*executable->pipeline_layouts) +
      executable_params->constant_count * sizeof(*executable_params->constants),
      (void**)&executable);

  executable->program = malloc(executable_params->executable_data.data_length);
  memcpy(executable->program, executable_params->executable_data.data, executable_params->executable_data.data_length);

  executable->pipeline_layout_count = executable_params->pipeline_layout_count;

  for (iree_host_size_t i = 0; i <  executable_params->pipeline_layout_count; ++i) {
    executable->pipeline_layouts[i] = executable_params->pipeline_layouts[i];
    iree_hal_pipeline_layout_retain(executable->pipeline_layouts[i]);
  }

  if (executable_params->constant_count > 0) {
    uint32_t* target_constants =
        (uint32_t*)((uint8_t*)executable + sizeof(*executable) +
                    executable_params->pipeline_layout_count *
                        sizeof(*executable->pipeline_layouts));
    memcpy(target_constants, executable_params->constants,
           executable_params->constant_count *
               sizeof(*executable_params->constants));
    executable->constants = target_constants;
  } else {
    executable->constants = NULL;
  }

  if (iree_status_is_ok(status)) {
    iree_hal_resource_initialize(&iree_hal_torq_native_executable_vtable,
                                 &executable->resource);
    executable->allocator = allocator;
    executable->entry_point_count = 0;
  }

  executable->device = device;

  if (iree_status_is_ok(status)) {
    *out_executable = (iree_hal_executable_t*)executable;
  } else {
    iree_hal_executable_destroy((iree_hal_executable_t*)executable);
  }

  if (FLAG_torq_debug) {
      TorqLogger::request_log_level = TORQ_LOG_DEBUG;
  }

  if (FLAG_torq_verbose) {
    TorqLogger::request_log_level = TORQ_LOG_VERBOSE;
  }

  if (FLAG_torq_step_by_step) {
    TorqLogger::request_log_level = TORQ_LOG_VERBOSE;
  }

  IREE_TRACE_ZONE_END(z0);
  return status;
}

static void iree_hal_torq_native_executable_destroy(
    iree_hal_executable_t* base_executable) {
  iree_hal_torq_native_executable_t* executable =
      iree_hal_torq_native_executable_cast(base_executable);
  iree_allocator_t host_allocator =
      executable->allocator;
  IREE_TRACE_ZONE_BEGIN(z0);

  iree_allocator_free(host_allocator, executable);

  IREE_TRACE_ZONE_END(z0);
}

typedef struct fake_npu_top_t
{
    void*    *torq_nss_regs;
    uint8_t*            lram;
    uint8_t*            xram;
} fake_npu_top_t;


iree_status_t sync_binding(int binding_id, iree_hal_torq_Binding_table_t binding, iree_hal_executable_dispatch_state_v0_t *state,
    TorqHw *torq, bool from_host, const string& executable_name, int job_id) {

    auto isReadOnly = ns(Binding_is_read_only(binding));

    if (isReadOnly && !from_host) {     
      return iree_ok_status();
    }

    auto isWriteOnly = ns(Binding_is_write_only(binding));

    if (isWriteOnly && from_host) {     
      return iree_ok_status();
    }

    auto bindingId = ns(Binding_id(binding));

    if (bindingId >= state->binding_count) {
      return iree_make_status(IREE_STATUS_INVALID_ARGUMENT, "binding id %d out of range [0, %d)", bindingId, state->binding_count);
    }

    auto bindingOffset = ns(Binding_offset(binding));
    auto bindingSize = ns(Binding_size(binding));

    if (bindingOffset >= state->binding_lengths[bindingId]) {
      return iree_make_status(IREE_STATUS_INVALID_ARGUMENT, "binding offset %d out of range [0, %zu)", bindingOffset, state->binding_lengths[bindingId]);
    }

    if (bindingOffset + bindingSize > state->binding_lengths[bindingId]) {
      return iree_make_status(IREE_STATUS_INVALID_ARGUMENT, "binding size %d with offset %d out of range [0, %zu)", bindingSize, bindingOffset, state->binding_lengths[bindingId]);
    }

    auto bindingAddress = ns(Binding_address(binding));

    uint8_t *hostAddress = (uint8_t *)state->binding_ptrs[bindingId] + bindingOffset;


    if (from_host) {

      if (!torq->writeXram(bindingAddress, bindingSize, hostAddress)) {
        return iree_make_status(IREE_STATUS_INTERNAL, "failed to writeXram()");
      }

    } else {

      if (!torq->readXram(bindingAddress, bindingSize, hostAddress)) {
        return iree_make_status(IREE_STATUS_INTERNAL, "failed to readXram()");
      }

    }

    // dump the whole binding data
    // only dump the valid input/output binding data
    std::string io_str;
    if (from_host && !isWriteOnly) {
      io_str = ".in";
    } else if (!from_host && !isReadOnly) {
      io_str = ".out";
    }

    if (FLAG_torq_dump_io_data_dir[0] && !io_str.empty()) {
        string data_file = "npu" + io_str + ".host_binding." + to_string(bindingId) + ".torq_binding." + to_string(bindingId) + ".bin";

        LOGD << "Writing binary dump of binding " << bindingId << " to " << get_io_dump_data_dir(executable_name) << "/" << data_file;

        binary_file_write(get_io_dump_data_dir(executable_name) + data_file, hostAddress, bindingSize);
    }
    
    if (FLAG_torq_dump_mem_data_dir[0] && !io_str.empty()) {
        const string file_name = "binding_" + to_string(bindingId) + io_str + ".txt";
        const string type = from_host ? "xload" : "xsave";
        if (!hex_file_write(executable_name, file_name, type, bindingAddress, hostAddress, bindingSize, job_id)) {
          return iree_make_status(IREE_STATUS_INTERNAL, "failed to dump binding data");
        }
    }

    return iree_ok_status();
}

static iree_status_t create_buffers_index(iree_hal_torq_native_executable_t* executable) {

  ns(ExecutableDef_table_t) executable_def = ns(ExecutableDef_as_root(executable->program));

  auto buffers = ns(ExecutableDef_buffers_debug_info(executable_def));

  // check if debug info is present
  if (!buffers) {
    LOGD << "No buffer debug info found in model";
    return iree_ok_status();
  }

  string executable_name = ns(ExecutableDef_executable_name(executable_def));

  auto path = std::string(FLAG_torq_dump_buffers_dir) + "/" + executable_name + "/buffers.csv";

  std::ofstream fp;
  fp.open(path, std::ios::out);

  if (!fp.is_open()) {
    return iree_make_status(IREE_STATUS_INTERNAL, "failed to open file %s", path.c_str());
  }


  auto actions = ns(ExecutableDef_actions(executable_def));

  fp << "id;type;shape;strides;address;size;allocation_action;last_use_action;deallocation_action;allocation_location;last_use_location;deallocation_location\n";

  for (int i = 0; i < ns(BufferDebugInfo_vec_len(buffers)); i++) {

    auto buffer = ns(BufferDebugInfo_vec_at(buffers, i));
  
    fp << ns(BufferDebugInfo_id(buffer)) << ";";
    fp << ns(BufferType_name(ns(BufferDebugInfo_buffer_type(buffer)))) << ";";
    
    auto shape = ns(BufferDebugInfo_shape_get(buffer));
    auto rank = flatbuffers_uint32_vec_len(shape);

    for (int j = 0; j < rank; j++) {
      fp << flatbuffers_uint32_vec_at(shape, j);      
      fp << "x";      
    }

    std::string element_type_str = ns(ElementType_name(ns(BufferDebugInfo_element_type(buffer))));
    std::transform(element_type_str.begin(), element_type_str.end(), element_type_str.begin(), ::tolower);
    fp << element_type_str << ";";

    auto strides = ns(BufferDebugInfo_strides_get(buffer));
    rank = flatbuffers_uint32_vec_len(strides);
    for (int j = 0; j < rank; j++) {
      fp << flatbuffers_uint32_vec_at(strides, j);
      if (j < rank - 1) {
        fp << ",";
      }    
    }

    auto allocationId = ns(BufferDebugInfo_allocation_action(buffer));
    auto allocationAction = ns(HostAction_vec_at(actions, allocationId));
    auto allocationLocation = ns(HostAction_location(allocationAction));

    auto deallocationId = ns(BufferDebugInfo_deallocation_action(buffer));
    if (deallocationId < 0) {
      deallocationId = ns(HostAction_vec_len(actions)) - 1;
    }
    auto deallocationAction = ns(HostAction_vec_at(actions, deallocationId));
    auto deallocationLocation = ns(HostAction_location(deallocationAction));

    auto lastUseId = ns(BufferDebugInfo_last_use_action(buffer));
    auto lastUseAction = ns(HostAction_vec_at(actions, lastUseId));
    auto lastUseLocation = ns(HostAction_location(lastUseAction));

    fp << ";";

    fp << ns(BufferDebugInfo_address(buffer)) << ";";

    fp << ns(BufferDebugInfo_size(buffer)) << ";";

    fp << allocationId << ";";

    fp << lastUseId << ";";

    fp << deallocationId << ";";

    fp << allocationLocation << ";";

    fp << lastUseLocation << ";";

    fp << deallocationLocation << ";";

    fp << "\n";
  }

  fp.close();

  return iree_ok_status();
  
}

iree_status_t create_dir(std::string dir_name) {
  error_code ec;
  filesystem::create_directory(dir_name, ec);
  if (ec && ec != std::errc::file_exists) {
    return iree_make_status(IREE_STATUS_INTERNAL, "failed to create directory %s: %s", dir_name.c_str(), ec.message().c_str());
  }
  return iree_ok_status();
}

iree_status_t create_job_directory(std::string executable_name, int job_id) {

  if (FLAG_torq_dump_buffers_dir[0]) {
    auto status = create_dir(std::string(FLAG_torq_dump_buffers_dir));
    if (!iree_status_is_ok(status)) {
      return status;
    }
    status = create_dir(std::string(FLAG_torq_dump_buffers_dir) + "/" + executable_name);
    if (!iree_status_is_ok(status)) {
      return status;
    }
  }

  if (FLAG_torq_dump_mem_data_dir[0]) {
    auto status = create_dir(FLAG_torq_dump_mem_data_dir);
    if (!iree_status_is_ok(status)) {
      return status;
    }
    status = create_dir(std::string(FLAG_torq_dump_mem_data_dir) + "/" + executable_name);
    if (!iree_status_is_ok(status)) {
      return status;
    }

    if (FLAG_torq_desc_data_dir[0]) {
      std::string template_dir = std::string(FLAG_torq_desc_data_dir) + "/" + executable_name + "/job" + std::to_string(job_id) + "/";

      if (filesystem::exists(template_dir)) {        
        auto mem_data_dir = get_mem_dump_data_dir(executable_name, job_id);

        if (!filesystem::exists(mem_data_dir)) {
          filesystem::copy(template_dir, get_mem_dump_data_dir(executable_name, job_id), filesystem::copy_options::recursive);
        }
      } else {
        status = create_dir(get_mem_dump_data_dir(executable_name, job_id));

        if (!iree_status_is_ok(status)) {
          return status;
        }

      }

    } else {
        auto status = create_dir(get_mem_dump_data_dir(executable_name, job_id));
        if (!iree_status_is_ok(status)) {
          return status;
        }
        // make sure the mem.lst files are empty as we will be appending to them
        filesystem::remove(get_mem_list_name(executable_name, true, job_id));
        filesystem::remove(get_mem_list_name(executable_name, false, job_id));
    }
  }

  return iree_ok_status();
}

static iree_status_t torq_execute_step_by_step(TorqHw *torq, int32_t code_entry, int32_t job_id) {

  // TODO: we reserve 640byte in lram for the code data,
  // to get this reserved value from somewhere
  static uint32_t const constexpr MAX_CODE_SIZE = 640;

  LOGD << "Reading code data from LRAM at entry point " << code_entry;

  vector<uint8_t> code_data_vec(MAX_CODE_SIZE);
  torq->readLram(code_entry, code_data_vec.size(), code_data_vec.data());

  LOGV << "Beginning to parse code data";

  auto cmds = parseCommandsUntilUnknown(code_data_vec);
  if (cmds.empty()) {
    return iree_make_status(IREE_STATUS_INTERNAL, "failed to parse code data");
  }

  uint32_t byte_offset = code_entry;

  std::vector<uint32_t> cmd_offsets;

  // patch the program to insert software breakpoints and collect the command offsets
  for (auto &cmd : cmds) {

    auto wasLastCommand = cmd->isLastCmd;

    cmd->isLastCmd = 1;
    cmd_offsets.push_back(byte_offset);
    byte_offset += cmd->serializedSize();

    // ignore other commands that would not be executed
    if (wasLastCommand) {
      break;
    }
  }

  auto patched_code = serializeCommands(cmds);
  auto patched_cmds = parseCommandsUntilUnknown(patched_code);

  if (patched_cmds.size() != cmds.size()) {
    LOGD << "Failed to patch code data, expected " << cmds.size() << " commands, but got " << patched_cmds.size();
    printCommands(patched_cmds);    

    return iree_make_status(IREE_STATUS_INTERNAL, "failed to parse patched code data");
  }

  // write back code with the sw breakpoints inserted
  torq->writeLram(code_entry, patched_code.size(), patched_code.data());

  // run each command and resume after each breakpoint
  for (int i = 0 ; i < cmd_offsets.size(); i++) {

    LOGV << "--------------";
    LOGV << "Stepping NPU at address " << cmd_offsets[i] << " command:";

    LOGV << "Registers before:";
    torq->printNssRegs();

    LOGV << "Executing instruction:";
    if (TorqLogger::request_log_level == TORQ_LOG_VERBOSE) {
      patched_cmds.at(i)->print();
    }

    if (!torq->start(cmd_offsets[i])) {
      LOGD << "Failed to start NPU at address " << cmd_offsets[i];
      return iree_make_status(IREE_STATUS_INTERNAL, "failed to start NPU");
    }
    
    if (!torq->wait()) {
      LOGD << "Failed to wait for NPU at address " << cmd_offsets[i];
      return iree_make_status(IREE_STATUS_INTERNAL, "failed to wait for NPU");
    }

    LOGV << "Registers after:\n";
    torq->printNssRegs();

  }

  return iree_ok_status();
}

static iree_status_t copy_to_hal_buffer(const std::vector<uint8_t>& src, iree_hal_allocator_t *allocator,               
              const std::vector<iree_device_size_t>& shape, const std::vector<iree_device_size_t>& strides,
              iree_hal_element_type_t element_type, iree_hal_buffer_t **dst) {
  

  size_t element_size_bits = iree_hal_element_bit_count(element_type);

  assert(element_size_bits % 8 == 0 && "Element size must be a multiple of 8");

  size_t element_size_bytes = element_size_bits / 8;

  size_t total_elements = 1;

  for (size_t i = 0; i < shape.size(); ++i) {
    total_elements *= shape[i];
  }

  iree_hal_buffer_t *hal_buffer;
  iree_hal_buffer_params_t params = {0};

  params.type = IREE_HAL_MEMORY_TYPE_HOST_LOCAL;
  params.access = IREE_HAL_MEMORY_ACCESS_ALL;
  params.usage = IREE_HAL_BUFFER_USAGE_DEFAULT;

  iree_status_t status = iree_hal_allocator_allocate_buffer(allocator, params, total_elements * element_size_bytes, &hal_buffer);

  if (!iree_status_is_ok(status)) {
    LOGD << "Failed to allocate buffer";
    iree_status_fprint(stderr, status);
    return status;
  }

  for (size_t i = 0; i < total_elements; i++) {
    size_t src_offset = 0;
    size_t remaining = i;

    for (size_t j = shape.size(); j > 0; j--) {
      size_t index = remaining % shape[j - 1];
      remaining /= shape[j - 1];
      src_offset += index * strides[j - 1] * element_size_bytes;
    }
    
    status = iree_hal_buffer_map_write(hal_buffer, i * element_size_bytes, src.data() + src_offset, element_size_bytes);
   
    if (!iree_status_is_ok(status)) {
      LOGD << "Failed to write to buffer";
      iree_status_fprint(stderr, status);
      return status;
    }

  }

  *dst = hal_buffer;

  return iree_ok_status();
  
}


static iree_status_t dump_to_numpy(std::string filePath, iree_hal_torq_native_executable_t* executable,                            
                            iree_hal_element_type_t element_type, const std::vector<uint8_t>& data,
                            const std::vector<iree_device_size_t>& shape, const std::vector<iree_device_size_t>& strides) {

  iree_status_t status = iree_ok_status();
  iree_io_stream_t* stream = NULL;
  iree_io_stdio_stream_mode_t mode = IREE_IO_STDIO_STREAM_MODE_WRITE | IREE_IO_STDIO_STREAM_MODE_DISCARD;

  iree_hal_allocator_t* allocator = iree_hal_device_allocator(executable->device);

  iree_hal_buffer_t *hal_buffer = NULL;

  status = copy_to_hal_buffer(data, allocator, shape, strides, element_type, &hal_buffer);

  if (!iree_status_is_ok(status)) {    
    return status;
  }    

  iree_string_view_t filePathStringView = iree_make_cstring_view(filePath.c_str());
  
  status = iree_io_stdio_stream_open(mode, filePathStringView, executable->allocator, &stream);

  if (!iree_status_is_ok(status)) {
    iree_hal_buffer_release(hal_buffer);
    iree_status_fprint(stderr, status);
    return status;
  }    

  iree_hal_buffer_view_t* buffer_view = NULL;

  status = iree_hal_buffer_view_create(hal_buffer, shape.size(), shape.data(), element_type, IREE_HAL_ENCODING_TYPE_DENSE_ROW_MAJOR, executable->allocator, &buffer_view);

  if (!iree_status_is_ok(status)) {
    iree_status_fprint(stderr, status);    
    iree_io_stream_release(stream);
    iree_hal_buffer_release(hal_buffer);
    return status;
  }

  status = iree_numpy_npy_save_ndarray(stream, IREE_NUMPY_NPY_SAVE_OPTION_DEFAULT, buffer_view, executable->allocator);

  if (!iree_status_is_ok(status)) {
    iree_status_fprint(stderr, status);    
  }

  iree_hal_buffer_view_release(buffer_view);
  iree_hal_buffer_release(hal_buffer);
  iree_io_stream_release(stream);
  
  return status;    
  
}

std::vector<iree_device_size_t> to_vector(flatbuffers_uint32_vec_t vec) {
  std::vector<iree_device_size_t> result;
  for (size_t i = 0; i < flatbuffers_uint32_vec_len(vec); i++) {
    result.push_back(flatbuffers_uint32_vec_at(vec, i));
  }
  return result;
}


iree_hal_element_type_t to_iree_hal_element_type(iree_hal_torq_ElementType_enum_t element_type) {
  switch (element_type) {
    case iree_hal_torq_ElementType_I8:
      return IREE_HAL_ELEMENT_TYPE_INT_8;
    case iree_hal_torq_ElementType_I16:
      return IREE_HAL_ELEMENT_TYPE_INT_16;
    case iree_hal_torq_ElementType_I32:
      return IREE_HAL_ELEMENT_TYPE_INT_32;
    case iree_hal_torq_ElementType_F32:
      return IREE_HAL_ELEMENT_TYPE_FLOAT_32;
    case iree_hal_torq_ElementType_BF16:
      return IREE_HAL_ELEMENT_TYPE_BFLOAT_16;
    default:
      return IREE_HAL_ELEMENT_TYPE_NONE;
  }
}

static void dump_buffers(TorqHw *torq, int32_t action_id, iree_hal_torq_native_executable_t* executable) {  

  auto executable_def = ns(ExecutableDef_as_root(executable->program));
  auto executable_name = ns(ExecutableDef_executable_name(executable_def));

  auto buffers = ns(ExecutableDef_buffers_debug_info(executable_def));
  if (!buffers) {
    LOGD << "No buffer debug info";
    return;
  }

  auto dump_dir = get_buffer_dump_dir(executable_name, action_id);

  if (!filesystem::exists(dump_dir)) {
    filesystem::create_directory(dump_dir);
  }

  auto actions = ns(ExecutableDef_actions(executable_def));
  auto action = ns(HostAction_vec_at(actions, action_id));

  if (ns(HostAction_params_type(action)) == ns(HostActionParams_StartNSSParams)) {
    LOGD << "Waiting for NPU components to finish before dumping buffers";

    auto params = ns(StartNSSParams_table_t) (ns(HostAction_params(action)));
    
    // wait for all components of the NPU that were started, we should not wait
    // for blocks that were not started as this will lead to an hang
    if (!torq->wait(true,
                      ns(StartNSSParams_starts_slice1(params)),
                      ns(StartNSSParams_starts_slice2(params)),
                      ns(StartNSSParams_starts_dma_in(params)),
                      ns(StartNSSParams_starts_dma_out(params)))) {

      LOGD << "Buffer dump may be incorrect due to NPU wait failed!";
    }
  }

  if (action_id == 0) {
      create_buffers_index(executable);
  }
  
  size_t buffer_count = ns(BufferDebugInfo_vec_len(buffers));

  for (size_t i = 0; i < buffer_count; i++) {

    auto buffer = ns(BufferDebugInfo_vec_at(buffers, i));

    if ( action_id < ns(BufferDebugInfo_allocation_action(buffer)) ||
         action_id > ns(BufferDebugInfo_last_use_action(buffer))) {
      continue;
    }

    auto elementType = to_iree_hal_element_type(ns(BufferDebugInfo_element_type_get(buffer)));

    // FIXME: we currently dump BF16 as UINT16 because iree doesn't support it
    if (elementType == IREE_HAL_ELEMENT_TYPE_BFLOAT_16) {
      elementType = IREE_HAL_ELEMENT_TYPE_UINT_16;
    }

    if (elementType == IREE_HAL_ELEMENT_TYPE_NONE) {
      LOGD << "Unsupported element type";
      continue;
    }

    auto bufferIndex = ns(BufferDebugInfo_id(buffer));
    uint32_t address = ns(BufferDebugInfo_address_get(buffer));
    uint32_t size = ns(BufferDebugInfo_size_get(buffer));

    // compute the effective size of the data, this is required because
    // subviews may have a total size (i.e. stride[0] * shape[0]) that
    // is larger than the actual data size and therefore reading the 
    // full size would result in reading out-of-bounds memory (that may
    // not be mappped)

    auto shape = to_vector(ns(BufferDebugInfo_shape(buffer)));
    auto strides = to_vector(ns(BufferDebugInfo_strides(buffer)));
    auto elementSizeBytes = iree_hal_element_dense_byte_count(elementType);
    
    // compute the address just after the last element in the buffer
    auto bufferDataLengthElements = 1;
    for (int dim = 0; dim < shape.size(); dim++) {
      bufferDataLengthElements += (shape[dim] - 1) * strides[dim];
    }    
    auto bufferDataLengthBytes = bufferDataLengthElements * elementSizeBytes;

    LOGD << "Dumping buffer " << bufferIndex << " at address " << address << " size " << size << " (data size " << bufferDataLengthBytes << ")";

    std::vector<uint8_t> stridedData(bufferDataLengthBytes);

    switch (ns(BufferDebugInfo_buffer_type_get(buffer))) {
      case ns(BufferType_XRAM):
        torq->readXram(address, bufferDataLengthBytes, stridedData.data());
        break;
      case ns(BufferType_LRAM):
        torq->readLram(address, bufferDataLengthBytes, stridedData.data());
        break;
      case ns(BufferType_DTCM):
        torq->readDtcm(address, bufferDataLengthBytes, stridedData.data());
        break;
      case ns(BufferType_ITCM):
        torq->readItcm(address, bufferDataLengthBytes, stridedData.data());
        break;
      default:
        LOGD << "Unsupported buffer type";
        continue;
    }

    auto file_path = dump_dir + "buffer_" + std::to_string(bufferIndex) + ".npy";

    iree_status_t status = dump_to_numpy(file_path, executable, elementType, stridedData, shape, strides);

    if (!iree_status_is_ok(status)) {
      LOGD << "Failed to dump buffer " << bufferIndex << " to file " << file_path;
      assert(false);
    }

  }


}

class ExecutionContext {

public:
  ExecutionContext(TorqHw* torq, iree_hal_torq_native_executable_t* nativeExecutable, TorqEventLog* eventLog) 
    : torq(torq), nativeExecutable(nativeExecutable), actionIndex(0), eventLog_(eventLog) {}

  iree_status_t enableProfiling(std::string profilingPath) {

    profilingFile.open(profilingPath);

    if (!profilingFile.good()) {
        return iree_make_status(IREE_STATUS_INTERNAL, "Failed to create timing dump file");
    }

    profilingFile << "id;time_since_open;time_since_start;location\n";

    return iree_ok_status();
    
  }

  iree_status_t run() {

    iree_status_t status = loadHostCode();

    if (!iree_status_is_ok(status)) {
      return status;
    }

    auto actions = ns(ExecutableDef_actions_get(executableDef()));
    size_t actionsCount = ns(HostAction_vec_len(actions));

    while(actionIndex < actionsCount) {

      auto action = ns(HostAction_vec_at(actions, actionIndex));
      
      LOGD << "Time since open:" << torq->getTimeSinceOpen();

      if (ns(HostAction_location_is_present(action))) {
        LOGD << "Starting action " << actionIndex << " at location " << ns(HostAction_location_get(action)) << ")";
      }

      status = processAction(action);

      if (!iree_status_is_ok(status)) {        
        return status;
      }
      
      if (ns(HostAction_location_is_present(action))) {
        LOGD << "Completed action " << actionIndex << " at location " << ns(HostAction_location_get(action)) << ")";
      }

      if (FLAG_torq_dump_buffers_dir[0]) {
        dump_buffers(torq, actionIndex, nativeExecutable);
      }

      actionIndex++;
    }

    return iree_ok_status();

  }

  ~ExecutionContext() {
    profilingFile.close();
    if (hostCodeLibHandle) {
      dlclose(hostCodeLibHandle);
    }
  }
  
  int lastCompletedJobId() {
    return pendingHostCopies ? jobId : jobId - 1;
  }

private:

  TorqHw* torq;
  iree_hal_torq_native_executable_t* nativeExecutable;   
  bool pendingHostCopies{false}; // true if there are host copies pending and therefore bindings are not up to date yet
  int actionIndex;
  int jobId{0};
  ofstream profilingFile;
  void *hostCodeLibHandle{nullptr};
  TorqEventLog* eventLog_{nullptr};

  ns(ExecutableDef_table_t) executableDef() {
    return ns(ExecutableDef_as_root(nativeExecutable->program));
  }

  std::string executableName() {
    return ns(ExecutableDef_executable_name(executableDef()));
  }

  iree_status_t loadHostCode() {

    auto hostCodeData = ns(ExecutableDef_host_code(executableDef()));

    auto hostCodeLen = flatbuffers_uint8_vec_len(hostCodeData);

    // host code not present, no need to load it
    if (hostCodeLen == 0) {
      return iree_ok_status();
    }

    // write hostCodeLib to the temporary file
    std::string tempFileName = "/tmp/host_code.so.XXXXXX";
    int fd = mkstemp(&tempFileName[0]);
    if (fd == -1) {
      return iree_make_status(IREE_STATUS_INTERNAL, "Failed to create temporary file");
    }
    
    std::ofstream ofs(tempFileName, std::ios::binary);
    if (!ofs.good()) {
      close(fd);
      return iree_make_status(IREE_STATUS_INTERNAL, "Failed to open temporary file for writing");
    }
    ofs.write(reinterpret_cast<const char*>(hostCodeData), hostCodeLen);
    ofs.close();
    close(fd);

    hostCodeLibHandle = dlopen(tempFileName.c_str(), RTLD_NOW | RTLD_LOCAL);

    return iree_ok_status();
  }

  iree_status_t processStartHostAction(ns(HostAction_table_t) action, ns(StartHostParams_table_t) params) {
    if (eventLog_) eventLog_->addEvent(Event{
        std::chrono::steady_clock::now(),
        EventType::HOST_PROGRAM_START,
        actionIndex,
        ns(HostAction_location_is_present(action)) ? ns(HostAction_location_get(action)) : ""
    });
    std::string functionName = ns(StartHostParams_function_name(params));

    LOGD << "action: Starting host with function " << functionName;

    auto hostFunction = (void(*)(iree_hal_executable_environment_v0_t*, iree_hal_executable_dispatch_state_v0_t*, iree_hal_executable_workgroup_state_v0_t*)) dlsym(hostCodeLibHandle, functionName.c_str());

    if (!hostFunction) {
      return iree_make_status(IREE_STATUS_INTERNAL, "Failed to find host function %s", functionName.c_str());
    }        

    auto args = ns(StartHostParams_args(params));
    auto sizes = ns(StartHostParams_sizes(params));

    if (flatbuffers_uint64_vec_len(args) != flatbuffers_uint64_vec_len(sizes)) {
      return iree_make_status(IREE_STATUS_INTERNAL, "Mismatched argument and size counts");
    }

    assert(sizeof(uintptr_t) == sizeof(uint64_t) && "Host pointer size not compatible");

    // read the arguments from XRAM 
    std::vector<std::vector<uint8_t>> arguments;
    std::vector<void*> argumentAddresses;

    for (int i = 0; i < flatbuffers_uint64_vec_len(args); i++) {
      std::vector<uint8_t> xramBuffer(flatbuffers_uint64_vec_at(sizes, i));
      torq->readXram(flatbuffers_uint64_vec_at(args, i), xramBuffer.size(), xramBuffer.data());
      arguments.push_back(std::move(xramBuffer));
      argumentAddresses.push_back(arguments.back().data());
    }

    // create the arguments for calling the code
    iree_hal_executable_environment_v0_t environment;
    iree_hal_executable_dispatch_state_v0_t dispatch_state;
    iree_hal_executable_workgroup_state_v0_t workgroup_state;

    memset(&environment, 0, sizeof(environment));
    memset(&dispatch_state, 0, sizeof(dispatch_state));
    memset(&workgroup_state, 0, sizeof(workgroup_state));

    dispatch_state.binding_count = argumentAddresses.size();
    dispatch_state.binding_ptrs = argumentAddresses.data();

    for (int i = 0; i < dispatch_state.binding_count; i++) {
        LOGD << "Argument " << i << ": " << std::hex << "0x" << (uintptr_t)dispatch_state.binding_ptrs[i] << " xram: 0x" << flatbuffers_uint64_vec_at(args, i) << std::dec << " size: " << flatbuffers_uint64_vec_at(sizes, i);
    }

    // call the code
    hostFunction(&environment, &dispatch_state, &workgroup_state);

    // read back the results to XRAM
    for (int i = 0; i < flatbuffers_uint64_vec_len(args); i++) {      
      torq->writeXram(flatbuffers_uint64_vec_at(args, i), arguments[i].size(), arguments[i].data());
    }
    if (eventLog_) eventLog_->addEvent(Event{
        std::chrono::steady_clock::now(),
        EventType::HOST_PROGRAM_END,
        actionIndex,
        ns(HostAction_location_is_present(action)) ? ns(HostAction_location_get(action)) : ""
    });
    return iree_ok_status();
  }

  iree_status_t processWaitHostAction(ns(HostAction_table_t) action, ns(WaitHostParams_table_t) params) {
    // host execution is synchronous for the moment so we don't need to do anything to wait
    return iree_ok_status();
  }

  iree_status_t processStartNSSAction(ns(HostAction_table_t) action, ns(StartNSSParams_table_t) params) {
      if (eventLog_) eventLog_->addEvent(Event{
        std::chrono::steady_clock::now(),
        EventType::NSS_START,
        actionIndex,
        ns(HostAction_location_is_present(action)) ? ns(HostAction_location_get(action)) : ""
      });
      uint32_t code_entry = ns(StartNSSParams_start_address(params));

      LOGD << "action: Starting NPU with entry point at " << code_entry;

      if (jobId > 0) {
        auto status = create_job_directory(executableName(), jobId);
        
        if (status != iree_ok_status()) {
          return status;
        }
        
      }

      if (FLAG_torq_step_by_step) {
        return torq_execute_step_by_step(torq, code_entry, actionIndex);
      }

      LOGD << "Starting NSS job " << jobId << " with code entry " << code_entry;

      if (!torq->start(code_entry)) {
          return iree_make_status(IREE_STATUS_INTERNAL, "torq failed to start with code entry %d", code_entry);
      }
      if (eventLog_) eventLog_->addEvent(Event{
        std::chrono::steady_clock::now(),
        EventType::NSS_START_END,
        actionIndex,
        ns(HostAction_location_is_present(action)) ? ns(HostAction_location_get(action)) : ""
      });
      return iree_ok_status();

  }

  iree_status_t processWaitNSSAction(ns(HostAction_table_t) action, ns(WaitNSSParams_table_t) params) {
    
    LOGD << "action: Waiting for NSS job " << jobId;
    if (eventLog_) eventLog_->addEvent(Event{
        std::chrono::steady_clock::now(),
        EventType::NSS_WAIT_START,
        actionIndex,
        ns(HostAction_location_is_present(action)) ? ns(HostAction_location_get(action)) : ""
    });
    if (!torq->wait()) {
        return iree_make_status(IREE_STATUS_INTERNAL, "torq failed to wait");
    }
    auto t_since_open = torq->getTimeSinceOpen();
    auto t_since_start = torq->getTimeSinceStart();

    LOGD << "Job " << jobId << " Time since open (ms): " << t_since_open / 1.e3 << " Time since start (us): " << static_cast<long>(t_since_start);

    if (profilingFile.good()) {
        
        profilingFile << jobId << ";" << t_since_open << ";" << t_since_start << ";";

        if (ns(HostAction_location_is_present(action))) {
          profilingFile << ns(HostAction_location_get(action));
        }

        profilingFile << endl;
    }

    if (!torq->end()) {
        return iree_make_status(IREE_STATUS_INTERNAL, "torq failed to end");
    }

    jobId++;
    pendingHostCopies = false;
    if (eventLog_) eventLog_->addEvent(Event{
        std::chrono::steady_clock::now(),
        EventType::NSS_WAIT_END,
        actionIndex,
        ns(HostAction_location_is_present(action)) ? ns(HostAction_location_get(action)) : ""
    });
    return iree_ok_status();

  }

  iree_status_t processHostCopyAction(ns(HostAction_table_t) action, ns(HostCopyParams_table_t) params) {
    if (eventLog_) eventLog_->addEvent(Event{
        std::chrono::steady_clock::now(),
        EventType::HOST_COPY_START,
        actionIndex,
        ns(HostAction_location_is_present(action)) ? ns(HostAction_location_get(action)) : ""
    });

    uint32_t inputAddress = ns(HostCopyParams_input_address(params));
    uint32_t outputAddress = ns(HostCopyParams_output_address(params));

    ns(BufferType_enum_t) inputType = ns(HostCopyParams_input_buffer_type(params));
    ns(BufferType_enum_t) outputType = ns(HostCopyParams_output_buffer_type(params));  

    auto inputStridesBytes = ns(HostCopyParams_input_strides_bytes(params));
    auto outputStridesBytes = ns(HostCopyParams_output_strides_bytes(params));

    auto shape = ns(HostCopyParams_shape(params));

    auto rank = flatbuffers_uint32_vec_len(shape);

    if (flatbuffers_uint32_vec_len(outputStridesBytes) != rank) {
      return iree_make_status(IREE_STATUS_INVALID_ARGUMENT, "incorrect output strides rank");
    }

    if (flatbuffers_uint32_vec_len(inputStridesBytes) != rank) {
      return iree_make_status(IREE_STATUS_INVALID_ARGUMENT, "incorrect input strides rank");
    }

    LOGD << "action: Copying " << ns(BufferType_name(inputType)) << "[" << inputAddress << 
              "] to " << ns(BufferType_name(outputType)) << "[" << outputAddress << "]";

    auto copyElement = [&] (int inputOffset, int outputOffset, int size) {
      vector<uint8_t> data(size);
    
      switch(inputType) {
        case ns(BufferType_XRAM):
          if (!torq->readXram(inputAddress + inputOffset, size, data.data())) {
            return iree_make_status(IREE_STATUS_INTERNAL, "failed to read from xram");
          }
          break;

        case ns(BufferType_LRAM):
          if (!torq->readLram(inputAddress + inputOffset, size, data.data())) {
            return iree_make_status(IREE_STATUS_INTERNAL, "failed to read from lram");
          }
          break;

        default:
          return iree_make_status(IREE_STATUS_INVALID_ARGUMENT, "unsupported memory type");
      }

      switch(outputType) {
        case ns(BufferType_XRAM):
          if (!torq->writeXram(outputAddress + outputOffset, size, data.data())) {
            return iree_make_status(IREE_STATUS_INTERNAL, "failed to write to xram");
          }
          break;

        case ns(BufferType_LRAM):
          if (!torq->writeLram(outputAddress + outputOffset, size, data.data())) {
            return iree_make_status(IREE_STATUS_INTERNAL, "failed to write to lram");
          }
          break;

        default:
          return iree_make_status(IREE_STATUS_INVALID_ARGUMENT, "unsupported memory type");
      }

      if (FLAG_torq_dump_mem_data_dir[0]) {
        const string file_name = "host_copy_" + std::to_string(actionIndex) + "_" + std::to_string(outputAddress + outputOffset) + ".txt";

        string type;

        if (outputType == ns(BufferType_LRAM)) {
          type = ""; 
        } else if (outputType == ns(BufferType_XRAM)) {
          type = "x";
        } else {
          return iree_make_status(IREE_STATUS_INVALID_ARGUMENT, "unsupported output memory type when dumping descriptors");
        }

        auto executableName = ns(ExecutableDef_executable_name(executableDef()));

        // load the data in the next job
        auto status = create_job_directory(executableName, jobId);
        if (status != iree_ok_status()) {
          return status;
        }

        if (!hex_file_write(executableName, file_name, type + "load", outputAddress + outputOffset, data.data(), data.size(), jobId)) {
          return iree_make_status(IREE_STATUS_INTERNAL, "failed to dump host copy data");
        }

        // save the data in the current job
        if (jobId > 0) {
          auto status = create_job_directory(executableName, jobId - 1);
          if (status != iree_ok_status()) {
            return status;
          }

          if (!hex_file_write(executableName, file_name, type + "save", outputAddress + outputOffset, data.data(), data.size(), jobId - 1)) {
            return iree_make_status(IREE_STATUS_INTERNAL, "failed to dump host copy data");
          }
        }
        
      }

      pendingHostCopies = true;

      return iree_ok_status();
    };

    std::function<iree_status_t(int, int, int)> copyDimension = [&] (int dim, int inputOffset, int outputOffset) {
      if (dim == rank) {
        auto elementSize = ns(HostCopyParams_element_size_bytes(params));
        auto ret = copyElement(inputOffset, outputOffset, elementSize);

        if (!iree_status_is_ok(ret)) {
          return ret;
        }
      } else {
        for (int i = 0; i < flatbuffers_uint32_vec_at(shape, dim); i++) {
          auto ret = copyDimension(dim + 1, inputOffset + i * flatbuffers_uint32_vec_at(inputStridesBytes, dim),
                                  outputOffset + i * flatbuffers_uint32_vec_at(outputStridesBytes, dim));
          if (!iree_status_is_ok(ret)) {
            return ret;
          }
        }
      }

      return iree_ok_status();

    };

    auto ret = copyDimension(0, 0, 0);  

    if (eventLog_) eventLog_->addEvent(Event{
        std::chrono::steady_clock::now(),
        EventType::HOST_COPY_END,
        actionIndex,
        ns(HostAction_location_is_present(action)) ? ns(HostAction_location_get(action)) : ""
    });

    return ret;
    
  }

  iree_status_t processAllocAction(ns(HostAction_table_t) action, ns(AllocParams_table_t) params) {
    if (eventLog_) eventLog_->addEvent(Event{
        std::chrono::steady_clock::now(),
        EventType::ALLOC_START,
        actionIndex,
        ns(HostAction_location_is_present(action)) ? ns(HostAction_location_get(action)) : ""
    });
    uint32_t id = ns(AllocParams_id(params));
    uint32_t address = ns(AllocParams_address(params));
    uint32_t size = ns(AllocParams_size(params));
    ns(BufferType_enum_t) bufferType = ns(AllocParams_buffer_type(params));

    LOGD << "action: Allocating buffer #" << id << ": " << ns(BufferType_name(bufferType)) << "[" << address << "] of size " << size;

    if (FLAG_torq_clear_memory) {
      std::vector<uint8_t> bufferData(size, 0);

      if (ns(BufferType_XRAM) == bufferType) {

        if (!torq->writeXram(address, size, bufferData.data())) {
          return iree_make_status(IREE_STATUS_INTERNAL, "failed to write to xram");
        }

      }
    }

    if (eventLog_) eventLog_->addEvent(Event{
        std::chrono::steady_clock::now(),
        EventType::ALLOC_END,
        actionIndex,
        ns(HostAction_location_is_present(action)) ? ns(HostAction_location_get(action)) : ""
    });

    return iree_ok_status();

  }

  iree_status_t processDeallocAction(ns(HostAction_table_t) action, ns(DeallocParams_table_t) params) {
    if (eventLog_) eventLog_->addEvent(Event{
        std::chrono::steady_clock::now(),
        EventType::DEALLOC_START,
        actionIndex,
        ns(HostAction_location_is_present(action)) ? ns(HostAction_location_get(action)) : ""
    });
    uint32_t id = ns(DeallocParams_id(params));

    LOGD << "action: Deallocating buffer #" << id;
    if (eventLog_) eventLog_->addEvent(Event{
        std::chrono::steady_clock::now(),
        EventType::DEALLOC_END,
        actionIndex,
        ns(HostAction_location_is_present(action)) ? ns(HostAction_location_get(action)) : ""
    });
    return iree_ok_status();

  }

  iree_status_t processAction(ns(HostAction_table_t) action) {
  
      auto params = ns(HostAction_params_get(action));

      switch (ns(HostAction_params_type(action))) {

        case ns(HostActionParams_HostCopyParams):
          return processHostCopyAction(action, (ns(HostCopyParams_table_t)) params);

        case ns(HostActionParams_StartNSSParams):
          return processStartNSSAction(action, (ns(StartNSSParams_table_t)) params);

        case ns(HostActionParams_WaitNSSParams):
          return processWaitNSSAction(action, (ns(WaitNSSParams_table_t)) params);
        
        case ns(HostActionParams_AllocParams):
          return processAllocAction(action, (ns(AllocParams_table_t)) params);

        case ns(HostActionParams_DeallocParams):
          return processDeallocAction(action, (ns(DeallocParams_table_t)) params);

        case ns(HostActionParams_StartHostParams):
          return processStartHostAction(action, (ns(StartHostParams_table_t)) params);

        case ns(HostActionParams_WaitHostParams):
          return processWaitHostAction(action, (ns(WaitHostParams_table_t)) params);

        default:
          return iree_make_status(IREE_STATUS_UNIMPLEMENTED, "unknown host action type %d", ns(HostAction_params_type(action)));
      }

  }

};

static iree_status_t compute_xram_footprint(ns(ExecutableDef_table_t) executable_def, iree_hal_executable_dispatch_state_v0_t *state, uint32_t* xram_base, uint32_t* xram_size) {

  int xram_start = UINT32_MAX;
  int xram_end = 0;

  LOGD << "XRAM memory map:";

  // iterate over all the segments and compute the xram start and end address of each to find the xram base and size
  iree_hal_torq_Segment_vec_t segments = ns(ExecutableDef_code_get(executable_def));
  size_t segments_count = ns(Segment_vec_len(segments));
  
  for (size_t i = 0; i < segments_count; i++) {
    iree_hal_torq_Segment_table_t segment = ns(Segment_vec_at(segments, i));
    
    uint32_t xram_address = ns(Segment_xram_address(segment));

    flatbuffers_uint8_vec_t code = ns(Segment_data(segment));
    size_t xram_segment_size = flatbuffers_uint8_vec_len(code);

    if (xram_address < xram_start) {
      xram_start = xram_address;
    }

    if (xram_address + xram_segment_size > xram_end) {
      xram_end = xram_address + xram_segment_size;      
      // FIXME: we add 640 because the compiler always reads 640 bytes for each segment
      // while the segment size is stricly only the code. We should fix the compiler
      // to read only what is necessary.
      xram_end += 640;
    }

    LOGD << "Segment " << i << ": xram_address=" << xram_address 
         << ", xram_segment_size=" << xram_segment_size 
         << ", xram_start=" << xram_start 
         << ", xram_end=" << xram_end;
  
  }

  // iterate over all the bindings and compute the xram start and end address of each to find the xram base and size
  iree_hal_torq_Binding_vec_t bindings = ns(ExecutableDef_bindings_get(executable_def));
  size_t bindings_count = ns(Binding_vec_len(bindings));
  for (size_t i = 0; i < bindings_count; i++) {
    iree_hal_torq_Binding_table_t binding = ns(Binding_vec_at(bindings, i));
    
    uint32_t xram_address = ns(Binding_address(binding));

    uint32_t xram_size_binding = ns(Binding_size(binding));

    if (xram_address < xram_start) {
      xram_start = xram_address;
    }

    if (xram_address + xram_size_binding > xram_end) {
      xram_end = xram_address + xram_size_binding;
    }

    LOGD << "Binding " << i << ": xram_address=" << xram_address 
         << ", xram_size_binding=" << xram_size_binding 
         << ", xram_start=" << xram_start 
         << ", xram_end=" << xram_end;
  }

  // iterate over all actions and find the xram start and end address of each alloc operation
  iree_hal_torq_HostAction_vec_t actions = ns(ExecutableDef_actions_get(executable_def));
  size_t actions_count = ns(HostAction_vec_len(actions));

  for (size_t i = 0; i < actions_count; i++) {
    iree_hal_torq_HostAction_table_t action = ns(HostAction_vec_at(actions, i));

    if (ns(HostAction_params_type(action)) == ns(HostActionParams_AllocParams)) {

      auto params = (ns(AllocParams_table_t)) ns(HostAction_params_get(action));

      if (ns(AllocParams_buffer_type(params)) != ns(BufferType_XRAM)) {
        continue;
      }

      uint32_t xram_address = ns(AllocParams_address(params));
      uint32_t xram_size_alloc = ns(AllocParams_size(params));

      if (xram_address < xram_start) {
        xram_start = xram_address;
      }

      if (xram_address + xram_size_alloc > xram_end) {
        xram_end = xram_address + xram_size_alloc;
      }

      LOGD << "Alloc Action " << i << ": xram_address=" << xram_address 
           << ", xram_size_alloc=" << xram_size_alloc 
           << ", xram_start=" << xram_start 
           << ", xram_end=" << xram_end;

    }
  }

  if (xram_start == UINT32_MAX || xram_end == 0) {
    *xram_base = 0;
    *xram_size = 0;
  }
  else {
    *xram_base = xram_start;
    *xram_size = xram_end - xram_start;
  }

  return iree_ok_status();

}

iree_status_t iree_hal_torq_native_executable_run(
    iree_hal_executable_t* base_value, 
    iree_hal_executable_dispatch_state_v0_t* dispatch_state) {

    iree_hal_torq_native_executable_t* executable = iree_hal_torq_native_executable_cast(base_value);
    iree_hal_executable_dispatch_state_v0_t* state = dispatch_state;

    LOGD << "Dispatch State:";
    LOGD << "  executable=" << base_value;
    LOGD << "  workgroup_count x=" << state->workgroup_count_x << " y=" << state->workgroup_count_y << " z=" << state->workgroup_count_z;
    LOGD << "  pipeline_layout_count=" << executable->pipeline_layout_count;
    LOGD << "  binding count=" << std::to_string(state->binding_count);
    LOGD << "  constants count=" << state->push_constant_count;

    for (iree_host_size_t i = 0; i < state->binding_count; ++i) {
        LOGD << "  binding[" << i << "]: buffer=" << state->binding_ptrs[i] << " length=" << state->binding_lengths[i];
    }

    iree_hal_torq_ExecutableDef_table_t executable_def =
      iree_hal_torq_ExecutableDef_as_root(executable->program);

    if (!iree_hal_torq_ExecutableDef_code_is_present(executable_def)) {
      return iree_make_status(IREE_STATUS_INTERNAL, "code is missing");
    }

    string executable_name = iree_hal_torq_ExecutableDef_executable_name_get(executable_def);

    if (FLAG_torq_dump_io_data_dir[0]) {
      auto status = create_dir(FLAG_torq_dump_io_data_dir);

      if (status != iree_ok_status()) {
        return status;
      }

      status = create_dir(get_io_dump_data_dir(executable_name));
      
      if (status != iree_ok_status()) {
        return status;
      }
    }

    auto status = create_job_directory(executable_name, 0);

    if (status != iree_ok_status()) {
      return status;
    }

    iree_hal_torq_Binding_vec_t bindings = iree_hal_torq_ExecutableDef_bindings_get(executable_def);
    size_t bindings_count = iree_hal_torq_Binding_vec_len(bindings);
    
    uint32_t xram_base, xram_size;
    TorqEventLog eventLog;
    auto ret = compute_xram_footprint(executable_def, state, &xram_base, &xram_size);

    if (!iree_status_is_ok(ret)) {
      return ret;
    }

    LOGD << "xram_base " << xram_base << " xram_end " << (xram_base + xram_size)  << " xram_size " << xram_size;
    LOGD << "Running executable " << executable_name;

    unique_ptr<TorqHw> torq = newTorqHw(FLAG_torq_hw_type, xram_base, xram_size, get_mem_dump_data_root_dir(executable_name), &eventLog);
    if (!torq.get() || !torq->open()) {
        return iree_make_status(IREE_STATUS_INTERNAL, "failed to open TorqHw");
    }

    LOGD << "Time since open:" << torq->getTimeSinceOpen();

    if (FLAG_torq_clear_memory) {
      std::vector<uint8_t> zeros(512 * 1024, 0);
      torq->writeLram(0, zeros.size(), zeros.data());

      std::vector<uint8_t> zeros1(xram_size, 0);
      torq->writeXram(xram_base, zeros1.size(), zeros1.data());
    }

    if (!iree_hal_torq_ExecutableDef_code_is_present(executable_def)) {
      return iree_make_status(IREE_STATUS_INTERNAL, "code is missing");
    }

    iree_hal_torq_Segment_vec_t segments = iree_hal_torq_ExecutableDef_code_get(executable_def);
    size_t segments_count = iree_hal_torq_Segment_vec_len(segments);


    for (size_t i = 0; i < segments_count; i++) {
      iree_hal_torq_Segment_table_t segment = iree_hal_torq_Segment_vec_at(segments, i);

      if (!iree_hal_torq_Segment_data_is_present(segment)) {
        return iree_make_status(IREE_STATUS_INTERNAL, "segment data is missing");
      }

      flatbuffers_uint8_vec_t code = iree_hal_torq_Segment_data_get(segment);
      size_t code_len = flatbuffers_uint8_vec_len(code);


      uint32_t xram_code_address = iree_hal_torq_Segment_xram_address_get(segment);

      if (xram_code_address != 1 ) {
      
        LOGD << "Loading code at XRAM address " << xram_code_address << ", len " << code_len;

          if (!torq->writeXram(xram_code_address, code_len, code)) {
            return iree_make_status(IREE_STATUS_INTERNAL, "failed to writeXram()");
          }
      }
    }

    LOGD << "Time since open:" << torq->getTimeSinceOpen();

    if (!iree_hal_torq_ExecutableDef_bindings_is_present(executable_def)) {
      return iree_make_status(IREE_STATUS_INTERNAL, "bindings are missing");
    }

    // simulate mapping bindings in the IO MMU of the NPU by copying the buffers in the cmodel
    for (size_t i = 0; i < bindings_count; i++) {
      iree_hal_torq_Binding_table_t binding = iree_hal_torq_Binding_vec_at(bindings, i);
      uint32_t binding_id = ns(Binding_id(binding));

      LOGD << "Loading binding " << binding_id << " index " << i;

      iree_status_t ret = sync_binding(i, binding, state, torq.get(), true, executable_name, 0);

      if (!iree_status_is_ok(ret)) {
        return ret;
      }
    }

    LOGD << "Time since open:" << torq->getTimeSinceOpen();

    ExecutionContext context(torq.get(), executable, &eventLog);

    if (FLAG_torq_profile[0]) {
      ret = context.enableProfiling(FLAG_torq_profile);
      if (!iree_status_is_ok(ret)) {
        return ret;
      }
    }

    //load the resources required for the network
    if (!torq->load())
      return iree_make_status(IREE_STATUS_INTERNAL, "failed to load HW resources for job run");

    ret = context.run();

    torq->release();

    if (!iree_status_is_ok(ret)) {
      torq->close();
      return ret;
    }

    LOGD << "Finished NPU";

    // simulate mapping bindings in the IO MMU of the NPU by copying back the binding buffers from the cmodel
    for (size_t i = 0; i < bindings_count; i++) {

      iree_hal_torq_Binding_table_t binding = iree_hal_torq_Binding_vec_at(bindings, i);
      uint32_t binding_id = ns(Binding_id(binding));

      LOGD << "Reading binding " << binding_id << " index " << i;

      iree_status_t ret = sync_binding(i, binding, state, torq.get(), false, executable_name, context.lastCompletedJobId());
      if (!iree_status_is_ok(ret)) {
        return ret;
      }
    }

    if (!torq->close()) {
        return iree_make_status(IREE_STATUS_INTERNAL, "torq failed to close");
    }

    if (FLAG_torq_profile_host[0]) {
      eventLog.dumpEvents(FLAG_torq_profile_host);
    }

    return iree_ok_status();
}

namespace {
const iree_hal_executable_vtable_t iree_hal_torq_native_executable_vtable = {
    /*.destroy=*/iree_hal_torq_native_executable_destroy,
};
}  // namespace
